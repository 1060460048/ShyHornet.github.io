<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Lanyon</title>
 <link href="http://lanyon.getpoole.com/atom.xml" rel="self"/>
 <link href="http://lanyon.getpoole.com/"/>
 <updated>2015-10-13T19:31:10+08:00</updated>
 <id>http://lanyon.getpoole.com</id>
 <author>
   <name>Mark Otto</name>
   <email>markdotto@gmail.com</email>
 </author>

 
 <entry>
   <title>Introducing Lanyon</title>
   <link href="http://lanyon.getpoole.com/2014/01/02/introducing-lanyon/"/>
   <updated>2014-01-02T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.com/2014/01/02/introducing-lanyon</id>
   <content type="html">&lt;p&gt;Lanyon is an unassuming &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; theme that places content first by tucking away navigation in a hidden drawer. It’s based on &lt;a href=&quot;http://getpoole.com&quot;&gt;Poole&lt;/a&gt;, the Jekyll butler.&lt;/p&gt;

&lt;h3 id=&quot;built-on-poole&quot;&gt;Built on Poole&lt;/h3&gt;

&lt;p&gt;Poole is the Jekyll Butler, serving as an upstanding and effective foundation for Jekyll themes by &lt;a href=&quot;https://twitter.com/mdo&quot;&gt;@mdo&lt;/a&gt;. Poole, and every theme built on it (like Lanyon here) includes the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Complete Jekyll setup included (layouts, config, &lt;a href=&quot;/404&quot;&gt;404&lt;/a&gt;, &lt;a href=&quot;/atom.xml&quot;&gt;RSS feed&lt;/a&gt;, posts, and &lt;a href=&quot;/about&quot;&gt;example page&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Mobile friendly design and development&lt;/li&gt;
  &lt;li&gt;Easily scalable text and component sizing with &lt;code&gt;rem&lt;/code&gt; units in the CSS&lt;/li&gt;
  &lt;li&gt;Support for a wide gamut of HTML elements&lt;/li&gt;
  &lt;li&gt;Related posts (time-based, because Jekyll) below each post&lt;/li&gt;
  &lt;li&gt;Syntax highlighting, courtesy Pygments (the Python-based code snippet highlighter)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lanyon-features&quot;&gt;Lanyon features&lt;/h3&gt;

&lt;p&gt;In addition to the features of Poole, Lanyon adds the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Toggleable sliding sidebar (built with only CSS) via &lt;strong&gt;☰&lt;/strong&gt; link in top corner&lt;/li&gt;
  &lt;li&gt;Sidebar includes support for textual modules and a dynamically generated navigation with active link support&lt;/li&gt;
  &lt;li&gt;Two orientations for content and sidebar, default (left sidebar) and &lt;a href=&quot;https://github.com/poole/lanyon#reverse-layout&quot;&gt;reverse&lt;/a&gt; (right sidebar), available via &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; classes&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/poole/lanyon#themes&quot;&gt;Eight optional color schemes&lt;/a&gt;, available via &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; classes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/poole/lanyon#readme&quot;&gt;Head to the readme&lt;/a&gt; to learn more.&lt;/p&gt;

&lt;h3 id=&quot;browser-support&quot;&gt;Browser support&lt;/h3&gt;

&lt;p&gt;Lanyon is by preference a forward-thinking project. In addition to the latest versions of Chrome, Safari (mobile and desktop), and Firefox, it is only compatible with Internet Explorer 9 and above.&lt;/p&gt;

&lt;h3 id=&quot;download&quot;&gt;Download&lt;/h3&gt;

&lt;p&gt;Lanyon is developed on and hosted with GitHub. Head to the &lt;a href=&quot;https://github.com/poole/lanyon&quot;&gt;GitHub repository&lt;/a&gt; for downloads, bug reports, and features requests.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>swift实现一个与智能机器人聊天的app(一)</title>
   <link href="http://lanyon.getpoole.com/2014/01/01/example-content/"/>
   <updated>2014-01-01T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.com/2014/01/01/example-content</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-e4b4dd2fe687ab5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;截图&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;你在本系列文章中将会学到&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;如何安装和使用cocoapods来集成第三方库&lt;/li&gt;
  &lt;li&gt;如何搭建一个类似于iOS短信app的界面,以及使用SnapKit来用代码设置autolayout&lt;/li&gt;
  &lt;li&gt;如何使用Parse云服务平台存储和同步聊天信息,学习相应地数据库知识&lt;/li&gt;
  &lt;li&gt;如何使用Parse的远程推送功能&lt;/li&gt;
  &lt;li&gt;如何使用Alamofire实现与智能机器人聊天功能
&lt;strong&gt;初始项目下载地址:&lt;/strong&gt;
&lt;a href=&quot;http://pan.baidu.com/s/1z71vg&quot;&gt;百度网盘下载地址&lt;/a&gt;
#配置初始项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1.cocoapods的安装&lt;/strong&gt;
cocoapods的安装是通过ruby，幸运的是Mac电脑都是默认安装ruby的，所以安装ruby的过程就省去了，唯一的前提就是安装Xcode的CommandLineTools。
commandLineTools的安装也很简单,只要在终端输入以下命令:
&lt;code&gt;
$ xcode-select --install
&lt;/code&gt;&lt;br /&gt;
如果确实没有安装commandLineTools会提示你要安装它，点安装就可以开始下载，然后等待下载完成后安装即可
下面开始安装cocoapods，本来只需要简单地在终端输入以下命令即可:&lt;br /&gt;
&lt;code&gt;
$ sudo gem install cocoapods
&lt;/code&gt;&lt;br /&gt;
但是由于中国的互联网是”自由的”。。咳咳，所以呢，你要改变gem的默认下载源:&lt;br /&gt;
&lt;code&gt;
$ gem sources -a http://ruby.taobao.org
&lt;/code&gt;&lt;br /&gt;
看到以下结果
&lt;code&gt;
http://ruby.taobao.org added to sources
&lt;/code&gt;
将淘宝的ruby源加入进来，看来淘宝也不光是卖东西哈，也是对开发者做了一些贡献的~
删除原来的下载源:
&lt;code&gt;
$ gem sources -r https://rubygems.org/
&lt;/code&gt;
看到以下结果就说明已经成功
&lt;code&gt;
https://rubygems.org/ removed from sources
&lt;/code&gt;
然后呢，就可以愉快地安装上cocoapods了！
 &lt;code&gt;
$ sudo gem install cocoapods
&lt;/code&gt;
&lt;code&gt;
Password:(你的管理员密码，这里不会显示出来)
Fetching: cocoapods-core-0.38.2.gem (100%)
Successfully installed cocoapods-core-0.38.2
Fetching: claide-0.9.1.gem (100%)
Successfully installed claide-0.9.1
Fetching: xcodeproj-0.26.3.gem (100%)
Successfully installed xcodeproj-0.26.3
Fetching: cocoapods-downloader-0.9.3.gem (100%)
Successfully installed cocoapods-downloader-0.9.3
Fetching: cocoapods-stats-0.5.3.gem (100%)
Successfully installed cocoapods-stats-0.5.3
Fetching: cocoapods-try-0.4.5.gem (100%)
Successfully installed cocoapods-try-0.4.5
Fetching: cocoapods-trunk-0.6.4.gem (100%)
Successfully installed cocoapods-trunk-0.6.4
Fetching: molinillo-0.3.1.gem (100%)
Successfully installed molinillo-0.3.1
Fetching: cocoapods-0.38.2.gem (100%)
Successfully installed cocoapods-0.38.2
Parsing documentation for cocoapods-core-0.38.2
Installing ri documentation for cocoapods-core-0.38.2
Parsing documentation for claide-0.9.1
Installing ri documentation for claide-0.9.1
Parsing documentation for xcodeproj-0.26.3
Installing ri documentation for xcodeproj-0.26.3
Parsing documentation for cocoapods-downloader-0.9.3
Installing ri documentation for cocoapods-downloader-0.9.3
Parsing documentation for cocoapods-stats-0.5.3
Installing ri documentation for cocoapods-stats-0.5.3
Parsing documentation for cocoapods-try-0.4.5
Installing ri documentation for cocoapods-try-0.4.5
Parsing documentation for cocoapods-trunk-0.6.4
Installing ri documentation for cocoapods-trunk-0.6.4
Parsing documentation for molinillo-0.3.1
Installing ri documentation for molinillo-0.3.1
Parsing documentation for cocoapods-0.38.2
Installing ri documentation for cocoapods-0.38.2
9 gems installed
&lt;/code&gt;
OK,cocoapods顺利安装完毕！
&lt;strong&gt;2.cocoapods的使用&lt;/strong&gt;
那么cocoapods怎么用呢，当然第一次使用会觉得它非常麻烦，但是呢渐渐地你会发现这是一个非常好用的工具，可以说是iOS开发者必备！
首先创建我们的Xcode工程:File/New/Project…/Single View Application
起名叫图灵聊天。
&amp;gt;我们将要使用图灵机器人的api进行开发:
&lt;a href=&quot;http://www.tuling123.com/openapi/cloud/home.jsp&quot;&gt;图灵机器人官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开项目，新建一个空文件:File/New/File…/ iOS/Others/Empty
&lt;strong&gt;起名叫Podfile，这一点非常重要,因为这是cocoapods的配置文件，也就是指定你要使用哪些第三方库!&lt;/strong&gt;
我们要使用以下几个库:
- Alamofire，网络请求库，用来调用图灵机器人的api
- SnapKit,用代码进行autolayout设置
- Parse ,Parse云服务平台的SDK
- ParseUI,Parse提供的便捷UI组件
在Podfile中,输入以下代码:
&lt;code&gt;
source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.4&#39;
use_frameworks!
&lt;/code&gt;
指定下载源，指定平台版本，使用framework进行集成
&amp;gt;由于swift的特殊性，某些第三方库必须使用framework来集成,但是这样也有一个好处，我也是最近才发现，就是Parse和ParseUI其实是OC编写的库，但是呢却不需要OC-Swift的桥接文件了！可以直接当做swift库来使用！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
pod &#39;Alamofire&#39;, &#39;~&amp;gt; 1.3&#39;
pod &#39;SnapKit&#39;, &#39;~&amp;gt; 0.12.0&#39;
pod &#39;Parse&#39;,&#39;~&amp;gt;1.7.1&#39;
pod &#39;ParseUI&#39;,&#39;~&amp;gt;1.1.3&#39;
&lt;/code&gt;
选择指定的第三方库及其版本&lt;/p&gt;

&lt;p&gt;开始安装第三方库,打开终端,将当前目录转到Podfile所在目录:
&lt;code&gt;
$ cd &amp;lt;Podfile所在目录&amp;gt;
&lt;/code&gt;
输入以下命令开始配置第三方库:
&lt;code&gt;
$ pod install
&lt;/code&gt;
&lt;code&gt;
Analyzing dependencies
Downloading dependencies
Using Alamofire (1.3.1)
Using Bolts (1.2.1)
Using Parse (1.7.5.3)
Using ParseUI (1.1.4)
Using SnapKit (0.12.0)
Generating Pods project
Integrating client project
Sending stats
&lt;/code&gt;
然后等待几分钟，如果一切正常，没有出现错误的话，打开项目文件后你会看到workspace的文件，以后都要使用这个文件来打开项目。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-c6ecdc03eb346dab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图1&quot; /&gt;
打开项目，看一下项目的结构:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-f482d9b61f5672e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目结构.png&quot; /&gt;
点一下Pods项目,你会发现所需的framework已经编译好了,只要在使用前import他们就可以了:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-0ceaff51b1b19ca4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Pods&quot; /&gt;
OK,到此我们的项目就配置好了，在我们开始搭建UI之前，先了解一下Parse的使用和一些必要配置
#配置Parse
首先打开Parse的官网：
&lt;a href=&quot;https://www.parse.com&quot;&gt;点我&lt;/a&gt;
注册一个新的用户,点击右上角的sign up :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-5f775e08f036c7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Parse注册.png&quot; /&gt;
以上用户名只是示例，但是app名称输入TuringChat。
注册完毕后，用你刚才注册的用户名登陆，应该会出现以下界面:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-1306b7039726bea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;主界面&quot; /&gt;
然后导入我们的示例数据:
&lt;a href=&quot;http://pan.baidu.com/s/1gdsBuWb&quot;&gt;点我下载&lt;/a&gt;
点击import按钮:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-864bef1a10e20d0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;导入数据&quot; /&gt;
选择刚才下载的文件:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-946156866d970bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据导入成功.png&quot; /&gt;
然后刚才导入的数据就会显示出来，并自动新建了一个数据库类:Messages
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-b08f51b1306050ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;数据.png&quot; /&gt;
我们来看一眼Messages类里都有什么:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;objectId&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统默认键&lt;/td&gt;
      &lt;td&gt;每一条数据都对应一个独一无二的id&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;incoming&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;用来确定该条信息是发送给我们的还是发送出去的&lt;/td&gt;
      &lt;td&gt;true就是发送来的反之就是我们发送出去的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;sentDate&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;消息发送时间&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;text&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;消息的内容&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;createdAt&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统默认键&lt;/td&gt;
      &lt;td&gt;数据创建时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;updatedAt&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统默认键&lt;/td&gt;
      &lt;td&gt;数据上一次更新的时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ACL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ACL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;系统默认键&lt;/td&gt;
      &lt;td&gt;数据的读写模式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;接下来我们来测试一下能否读取到这些数据，首先要获得该app的application ID和Client Key:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-243da2025a3f18f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;获取Key&quot; /&gt;
红线划掉的那两行就是我们需要的。
然后打开项目中的&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;，增加对Parse库的引用:
&lt;code&gt;
import Parse
&lt;/code&gt;
找到以下方法
&lt;code&gt;
  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool 
&lt;/code&gt;
在里面添加代码:
&lt;code&gt;
    Parse.setApplicationId(&quot;CYdFL9mvG8jHqc4ZA5PJsWMInBbMMun0XCoqnHgf&quot;, clientKey: &quot;6tGOC1uIKeYp5glvJE6MXZOWG9pmLtMuIUdh2Yzo&quot;)
&lt;/code&gt;
连接Parse的服务器
&lt;code&gt;
        var query = PFQuery(className: &quot;Messages&quot;)
        query.orderByAscending(&quot;sentDate&quot;)
        query.findObjectsInBackgroundWithBlock { (objects,error) -&amp;gt; Void in
            for object in objects as! [PFObject]{
            let incoming:Bool = object[&quot;incoming&quot;] as! Bool
            let text:String = object[&quot;text&quot;] as! String
            let sentDate:NSDate = object[&quot;sentDate&quot;] as! NSDate
            println(&quot;\(object.objectId!)\n\(incoming)\n\(text)\n\(sentDate)&quot;)
        }
     }
&lt;/code&gt;
新建查询，查询我们刚才所建的&lt;code&gt;Messages&lt;/code&gt;类，用&lt;code&gt;findObjectsInBackgroundWithBlock&lt;/code&gt;方法取出查询结果，并用一个循环全部打印出来。
cmd+R运行一下，如果没有问题会输出类似下面的内容:
&lt;code&gt;
oYtildSAOz
false
你叫什么名字？
2015-08-28 06:42:00 +0000
LX7kxmmiEp
true
我叫灵灵，聪明又可爱的灵灵
2015-08-28 06:43:00 +0000
p62dmgGIAS
false
你爱不爱我？
2015-08-28 06:43:00 +0000
oWReOM43Nf
true
爱你么么哒
2015-08-28 06:44:00 +0000
mtl2BGt3Mu
false
今天北京天气如何？
2015-08-29 03:59:00 +0000
DikAu5P2Nn
true
北京:08/29 周六,20-29° 28° 雷阵雨 微风小于3级;08/30 周日,19-27° 雷阵雨 微风小于3级;08/31 周一,19-27° 雷阵雨 微风小于3级;09/01 周二,20-26° 雷阵雨 微风小于3级;
2015-08-29 03:59:01 +0000
&lt;/code&gt;
很好，我们的数据库连接没有问题,那么下面开始搭建我们的UI。&lt;/p&gt;

&lt;h1 id=&quot;ui&quot;&gt;搭建UI&lt;/h1&gt;
&lt;p&gt;我们需要搭建的UI只是聊天页面，我们首先来看一看聊天页面的结构:
界面主要由以下三个部分组成
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-03d57b8222eede17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;UI结构&quot; /&gt;
那么这三部分怎样去实现呢，我先向大家做一些简单的介绍:
&lt;strong&gt;1.导航栏&lt;/strong&gt;
这一部分实现比较简单，只要把视图控制器嵌套在一个导航控制器(&lt;strong&gt;UINavigationController&lt;/strong&gt;)中即可，然后对其外观进行一些定制化操作。
&lt;strong&gt;2.聊天窗口&lt;/strong&gt;
这一部分用UITableView来构建。仔细观察你会发现这里一共有三种UITableViewCell:
- 用来显示消息发送日期的cell
- 发送消息气泡的cell
- 接收消息气泡的cell
但其实我们只需要两个，因为后两种cell区别只是是颜色和位置，我们只要判断一下该消息是发送的还是接收的，然后相应进行处理即可!
两种cell都是用的以下这个素材:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-b37e5cf608b0c975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MessageBubble.png&quot; /&gt;
但是，你会问，它为啥是黑色的！怎么让他变成图中的两种颜色呢？还有明明聊天气泡的大小是不定的，这样一张图怎么能满足所有尺寸呢？
有疑问很好，因为它可以成为你学习的动力，我们会在接下来向大家解释这是如何实现的！Be patient!
&lt;strong&gt;3.输入框&lt;/strong&gt;
这里我们要通过重写&lt;code&gt;UIResponder&lt;/code&gt;类的&lt;code&gt;inputAccessoryView&lt;/code&gt;属性来自定义我们的输入框，这样做的好处是我们的输入框会和系统的键盘结合起来，可以让其成为第一响应者(first responder)，一旦它成为第一响应者，我们自定义的输入框会跟随键盘一同弹出和收回，就像真正的短信app那样，这个方法比我有一篇文章所写的&lt;a href=&quot;http://www.jianshu.com/p/4e755fe09df7&quot;&gt;实现类似微信的输入框跟随键盘弹出的效果&lt;/a&gt;的方法还要更好一些,所以说方法不是绝对的，因为你总是能够找到更好的方法，所以,编程的时候要经常在脑子里想”嗯，一定还有更好的方法”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;嗯好嘞，废话不多说，下面我们就来一步一步地一一实现它们！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先从最简单的做起,实现自定义导航栏:
打开初始项目你会看到模板文件已经全部建好:
找到&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;文件中的以下方法:
&lt;code&gt;swift 
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
&lt;/code&gt;
在其中添加如下代码：
```
        var ChatVC:ChatViewController = ChatViewController()
        ChatVC.title = “灵灵”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    UINavigationBar.appearance().tintColor = UIColor(red: 0.05, green: 0.47, blue: 0.91, alpha: 1.0)
    UINavigationBar.appearance().barTintColor = UIColor(red: 0.05, green: 0.47, blue: 0.91, alpha: 1.0)
    UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName: UIColor.whiteColor()]
    UIApplication.sharedApplication().statusBarStyle = UIStatusBarStyle.LightContent
    var navigationVC:UINavigationController = UINavigationController(rootViewController: ChatVC)
    
    let frame = UIScreen.mainScreen().bounds
    window = UIWindow(frame: frame)
    window!.rootViewController = navigationVC
    window!.makeKeyAndVisible() ``` 设置app启动时显示我们自定义的视图控制器,并设置一下导航栏的外观。 ok,第一部分完成。 接下来我们来实现一下第三部分:输入框，我们要把最难的第二部分留在最后( ⊙ o ⊙ ) 打开**ChatViewController.swift**文件: 添加一些全局常量,在import下面class的定义之上: ``` let messageFontSize: CGFloat = 17 let toolBarMinHeight: CGFloat = 44 ``` 第一个是消息所用的字体大小,第二个是我们输入框的高度。 添加一些组成输入框的组件: ```
var toolBar: UIToolbar!
var textView: UITextView!
var sendButton: UIButton! ``` toolBar用来承载输入框中的组件,之所以用UIToolbar是因为它默认出现在屏幕最下方，就像你的短信输入框那样。 textView是我们输入文字的地方，而sendButton则是我们的发送按钮。 下面实现我们重写的**inputAccessoryView**,在这之前先让我们的视图控制器遵循`UITextViewDelegate`协议: ``` class ViewController: UIViewController,UITextViewDelegate { .... .... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;
下面添加以下代码来声明对**inputAccessoryView**的重写:
&lt;/code&gt;
 override var inputAccessoryView: UIView! {&lt;/p&gt;

&lt;p&gt;}
&lt;code&gt;
用get的方式将输入框的组件进行配置:
在大括号内部添加代码:
&lt;/code&gt;swift
        get {
            if toolBar == nil {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            toolBar = UIToolbar(frame: CGRectMake(0, 0, 0, toolBarMinHeight-0.5))
            
            textView = InputTextView(frame: CGRectZero)
            textView.backgroundColor = UIColor(white: 250/255, alpha: 1)
            textView.delegate = self
            textView.font = UIFont.systemFontOfSize(messageFontSize)
            textView.layer.borderColor = UIColor(red: 200/255, green: 200/255, blue: 205/255, alpha:1).CGColor
            textView.layer.borderWidth = 0.5
            textView.layer.cornerRadius = 5
            //            textView.placeholder = &quot;Message&quot;
            textView.scrollsToTop = false
            textView.textContainerInset = UIEdgeInsetsMake(4, 3, 3, 3)
            toolBar.addSubview(textView)
            
            sendButton = UIButton.buttonWithType(.System) as! UIButton
            sendButton.enabled = false
            sendButton.titleLabel?.font = UIFont.boldSystemFontOfSize(17)
            sendButton.setTitle(&quot;发送&quot;, forState: .Normal)
            sendButton.setTitleColor(UIColor(red: 142/255, green: 142/255, blue: 147/255, alpha: 1), forState: .Disabled)
            sendButton.setTitleColor(UIColor(red: 0.05, green: 0.47, blue: 0.91, alpha: 1.0), forState: .Normal)
            sendButton.contentEdgeInsets = UIEdgeInsets(top: 6, left: 6, bottom: 6, right: 6)
            sendButton.addTarget(self, action: &quot;sendAction&quot;, forControlEvents: UIControlEvents.TouchUpInside)
            toolBar.addSubview(sendButton)
            
            // 对组件进行Autolayout设置
            textView.setTranslatesAutoresizingMaskIntoConstraints(false)
            sendButton.setTranslatesAutoresizingMaskIntoConstraints(false)
   
            toolBar.addConstraint(NSLayoutConstraint(item: textView, attribute: .Left, relatedBy: .Equal, toItem: toolBar, attribute: .Left, multiplier: 1, constant: 8))
            toolBar.addConstraint(NSLayoutConstraint(item: textView, attribute: .Top, relatedBy: .Equal, toItem: toolBar, attribute: .Top, multiplier: 1, constant: 7.5))
            toolBar.addConstraint(NSLayoutConstraint(item: textView, attribute: .Right, relatedBy: .Equal, toItem: sendButton, attribute: .Left, multiplier: 1, constant: -2))
            toolBar.addConstraint(NSLayoutConstraint(item: textView, attribute: .Bottom, relatedBy: .Equal, toItem: toolBar, attribute: .Bottom, multiplier: 1, constant: -8))
            toolBar.addConstraint(NSLayoutConstraint(item: sendButton, attribute: .Right, relatedBy: .Equal, toItem: toolBar, attribute: .Right, multiplier: 1, constant: 0))
            toolBar.addConstraint(NSLayoutConstraint(item: sendButton, attribute: .Bottom, relatedBy: .Equal, toItem: toolBar, attribute: .Bottom, multiplier: 1, constant: -4.5))
        }
        return toolBar
    } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现有一个错误,这是因为我们的InputTextView是一个单独定义的类,它还没有定义，我们在之后会对他做一些操作，目前先不用管它，不过我们先把它定义出来，在视图控制器类之外定义该类:
```
class InputTextView: UITextView {&lt;/p&gt;

&lt;p&gt;}
&lt;code&gt;
还有一个问题，用系统默认的代码实现autolayout看起来很难理解，所以这里可以用第三方库SnapKit来实现,把上面设置autolayout的代码替换成以下代码:
&lt;/code&gt;
textView.setTranslatesAutoresizingMaskIntoConstraints(false)           &lt;br /&gt;
sendButton.setTranslatesAutoresizingMaskIntoConstraints(false)&lt;/p&gt;

&lt;p&gt;textView.snp_makeConstraints({ (make) -&amp;gt; Void in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                make.left.equalTo(self.toolBar.snp_left).offset(8)
                make.top.equalTo(self.toolBar.snp_top).offset(7.5)
                make.right.equalTo(self.sendButton.snp_left).offset(-2)
               make.bottom.equalTo(self.toolBar.snp_bottom).offset(-8)
              
            
            })
            sendButton.snp_makeConstraints({ (make) -&amp;gt; Void in
                make.right.equalTo(self.toolBar.snp_right)
                 make.bottom.equalTo(self.toolBar.snp_bottom).offset(-4.5)
                
            })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;
是不是看起来简洁多了?我们来解释一下这段代码:
每一个组件都有一个 `snp_makeConstraints`的闭包方法，用来设置约束,`textView.snp_makeConstraints`就是来设置textView的约束
闭包中` make.left.equalTo(self.toolBar.snp_left).offset(8)`这行代码可以用公式来表示:
也就是`textView.left = self.toolBar.left + 8`，这样一看就很直观了，文字框的左侧距输入框左侧8点。
 `make.top.equalTo(self.toolBar.snp_top).offset(7.5)`可以用公式
`textView.top = self.toolBar.top +7.5`表示，剩下的代码以此类推，如下图所示:
![autoLaout](http://upload-images.jianshu.io/upload_images/727794-31cebfa57f9e484f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
sendButton的部分也是如此:
`make.right.equalTo(self.toolBar.snp_right)`表示发送按钮右侧直接贴输入框的右侧,没有位移
`make.bottom.equalTo(self.toolBar.snp_bottom).offset(-4.5)`发送按钮底部距离输入框底部4.5点
这样是不是让autoLayout变得简单很多了？后面的项目我们就一直使用它来进行autoLayout设置了！
现在没有错误了,cmd+R运行一下，啊哦，为啥是空白！作者你骗人！( ⊙ o ⊙ )
=  =好吧，我们还差一步，记得吗，它要变成第一响应者才能弹出键盘哦,我们要重写一个方法它才能生效!在视图控制器类中增加以下方法:
&lt;/code&gt;
   override func canBecomeFirstResponder() -&amp;gt; Bool {
        return true
    }
```
告诉我们的系统我们自定义的输入框可以成为第一响应者，我们也是有身份证的！
然后在运行一下,如果没有错误，应该会有以下效果:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-631ea320c1b221a9.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;chat.gif&quot; /&gt;
忽略黑洞洞的背景，因为我们还没有添加内容。。。
但是你会发现一个问题，键盘怎么回来啊。。不管怎么点都没有反应啊！&lt;/p&gt;

&lt;p&gt;好吧，下面我们来用一个巧妙的办法来解决它。由于聊天页面是一个&lt;strong&gt;UITableView&lt;/strong&gt;，所以我们可以使用&lt;strong&gt;UITableViewContoller&lt;/strong&gt;来替代我们的&lt;strong&gt;UIViewContoller&lt;/strong&gt;，这样我们的页面中就默认有了一个&lt;strong&gt;UITableView&lt;/strong&gt;,然后它有一个非常实用的属性—&lt;code&gt;keyboardDismissMode&lt;/code&gt;，我们把它设置为&lt;code&gt;.Interactive&lt;/code&gt;也就是键盘的弹出和收回状态可以根据你对tableView的拖拽进行改变,也就是你的手指拖到哪里你的键盘就到哪里，是不是很酷。
改变视图控制器的类型:
&lt;code&gt;swift
class ChatViewController:UITableViewController,UITextViewDelegate {
....
....
....
}
&lt;/code&gt;
在viewDidLoad里添加一行代码来设置&lt;code&gt;keyboardDismissMode&lt;/code&gt;:
&lt;code&gt;
tableView.keyboardDismissMode = .Interactive
&lt;/code&gt;
再次运行，你会发现黑洞洞的背景不见了,取而代之的是空白的TableView！而且键盘也实现了炫酷的效果！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/727794-96018225631cff0a.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;chat.gif&quot; /&gt;
&lt;a href=&quot;https://github.com/ShyHornet/TuringchatProject/tree/step1&quot;&gt;文章本部分源代码&lt;/a&gt;
好的，第三部分顺利实现！第二部分是我们的重头戏，内容较多，所以我把它放到教程的第二部分中。
第二部分教程已经出炉，欢迎围观！
&lt;a href=&quot;http://www.jianshu.com/p/f2488a659688&quot;&gt;swift实现一个与智能机器人聊天的app(二)&lt;/a&gt;
##如果该文章对你有帮助，请点一下喜欢！您的支持是我继续写作的动力！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>What's Jekyll?</title>
   <link href="http://lanyon.getpoole.com/2013/12/31/whats-jekyll/"/>
   <updated>2013-12-31T00:00:00+08:00</updated>
   <id>http://lanyon.getpoole.com/2013/12/31/whats-jekyll</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; is a static site generator, an open-source tool for creating simple yet powerful websites of all shapes and sizes. From &lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/README.markdown&quot;&gt;the project’s readme&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jekyll is a simple, blog aware, static site generator. It takes a template directory […] and spits out a complete, static website suitable for serving with Apache or your favorite web server. This is also the engine behind GitHub Pages, which you can use to host your project’s page or blog right here from GitHub.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It’s an immensely useful tool and one we encourage you to use here with Lanyon.&lt;/p&gt;

&lt;p&gt;Find out more by &lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;visiting the project on GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
